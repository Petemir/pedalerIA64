\documentclass[a4paper,spanish,12pt]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{vmargin}
\usepackage{float}
\usepackage{lastpage}
\usepackage{caratula}
\usepackage{url}
\usepackage{listings}
\usepackage{multirow}
%\usepackage{textcomp}
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage[all]{hypcap}
\usepackage{array,booktabs}

%\hypersetup{
%    colorlinks,
%    citecolor=black,
%    filecolor=black,
%    linkcolor=black,
%    urlcolor=black
%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Para que las imagenes queden en donde esta el comando poner esto en el       %
% preambulo y usar los flags de posicion htp o htpb                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Alter some LaTeX defaults for better treatment of figures:
% See p.105 of "TeX Unbound" for suggested values.
% See pp. 199-200 of Lamport's "LaTeX" book for details.
%   General parameters, for ALL pages:
\renewcommand{\topfraction}{0.9}	% max fraction of floats at top
\renewcommand{\bottomfraction}{0.8}	% max fraction of floats at bottom
%   Parameters for TEXT pages (not float pages):
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{4}     % 2 may work better
\setcounter{dbltopnumber}{2}    % for 2-column pages
\renewcommand{\dbltopfraction}{0.9}	% fit big float above 2-col. text
\renewcommand{\textfraction}{0.07}	% allow minimal text w. figs
%   Parameters for FLOAT pages (not text pages):
\renewcommand{\floatpagefraction}{0.7}	% require fuller float pages
% N.B.: floatpagefraction MUST be less than topfraction !!
\renewcommand{\dblfloatpagefraction}{0.7}	% require fuller float pages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ECO Para jugar con el footer. 		%
\usepackage{fancyhdr}					%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%\usepackage{hyphenat}
%%\exhyphenpenalty=10000
%%\hyphenpenalty=10000
\setmarginsrb{10mm}% left margin
{15mm}% top margin
{15mm}% right margin
{10mm}% bottom margin
{0mm}{10mm}{0mm}{20mm}% we needed -- related to headers and footers

%%%%%%%%%
\pagestyle{fancy}
\fancyhf{}
\setlength\headheight{14.5pt}
\fancyhead[L, CE]{PedalerIA64 (Organización del Computador II)}
\fancyhead[R, CE]{Laporte Matías}
\fancyfoot[C]{ \thepage\ de \pageref{LastPage} }


%%%%%%%%%%

\begin{document}


%*************************************************************%
%                                                             %
% CARATULA                                                    %
%                                                             %
%*************************************************************%
    \materia{Organizaci\'on del Computador II}

    \titulo{Trabajo Práctico Final: PedalerIA64}
    \subtitulo{\textit{Informe}}

    \integrante{Laporte Matías}{686/09}{matiaslaporte@gmail.com}
    
    \maketitle
    
%*************************************************************%
%                                                             %
% INFORME                                                     %
%                                                             %
%*************************************************************%

\section{Introducción}
\label{sec:introduccion}

\indent El presente Trabajo Práctico consiste en el desarrollo de diversos efectos de audio que se pueden encontrar en softwares de edición en el contexto musical (Cubase, Reaktor, Audacity, etc.), así como también en pedaleras (de allí el nombre del programa) para el caso específico de una guitarra.

\subsection{Proceso de desarrollo del TP}
\label{subsec:intro-desarrollo}
El proceso de desarrollo del \textbf{TP} consistió en realizar en primera instancia un rápido prototipado en Matlab/RStudio/Scilab (dependiendo de la disponibilidad de la computadora que se usara en ese momento; de ahora en más, me referiré a esos programas como \textbf{MRS}) de algoritmos y ecuaciones que se pudieran encontrar en Internet de diversos efectos. El uso de esos programas como primer acercamiento a un efecto facilitaba enormemente el trabajo, pues al utilizar un lenguaje de muy alto nivel se simplificaba el manejo de la lectura y escritura de los archivos, el espacio en memoria para los mismos, la manipulación de los datos (poder trabajar trabajar sobre un vector entero con una sola operación, por ejemplo), etc.\vspace{\baselineskip}

Una vez certificado que con ese algoritmo se consiguiera el efecto auditivo deseado, se pasó a desarrollarlo en \textbf{C}, siempre verificando que el resultado final de la señal coincidiera con el obtenido en \textbf{MRS}. Como utilizar el comando \textit{diff} de UNIX directamente sobre los archivos no siempre daba el resultado querido (aventuro a decir que por diferencias de aproximación entre \textbf{MRS} y \textbf{C}), se optó por otra metodología utilizando el programa \textbf{Audacity}, que se explicará en la sección \ref{subsec:chequeo-diferencias}.\vspace{\baselineskip}

Obtenido el resultado deseado utilizando \textbf{C}, se pasó finalmente a programar el mismo algoritmo en \textbf{Assembler}, haciendo uso de las instrucciones que ofrece el conjunto de instrucciones SSE para manejar múltiples datos con una única instrucción (SIMD). Se utilizaron instrucciones incluidas hasta la extensión SSE4 (principalmente por \textit{PTEST}, y \textit{ROUNDPS}/\textit{ROUNDSS}). Luego de obtener en \textbf{Assembler} un código que parecía aceptable (es decir, que no terminara abruptamente con un segfault), se comenzó con un proceso iterativo de corrección, mediante la comparación del archivo de audio obtenido con el de \textbf{C}, utilizando \textbf{Audacity} como se mencionó previamente. Las diferencias entre ambos muchas veces provenían de casos bordes, que se los mencionará en la sección \ref{subsec:problemas-en-desarrollo}.\vspace{\baselineskip}

El objeto de la programación en \textbf{C} además de Assembler, si bien implica el ''doble'' de trabajo, se debe a dos puntos en particular. En primer medida, era una buena manera de poder bajar el nivel del código original en \textbf{MRS}, despojándolo de las bondades que dichas herramientas ofrecen. Por otro lado, tener el código en \textbf{C} sirve también para comparar la mejora de rendimiento con el uso de las instrucciones SIMD. \vspace{\baselineskip}

Para calcular el rendimiento en ambos lenguajes se utilizó la librería \textit{Tiempo.h} utilizada por la cátedra en el \textbf{TP N\degree 2} del 1er. Cuatrimestre de 2011. Cuando los resultados con la misma no eran satisfactorios (p.ej., \textbf{Assembler} era más lento que \textbf{C}), se procedió a utilizar una herramienta de profiling (\textbf{callgrind} en conjunto con \textbf{KCacheGrind}, se hablará de ellas más adelante) para poder identificar dónde exactamente estaban las secciones lentas del código en \textbf{Assembler}, y poder tomar medidas para resolverlo. De los casos puntuales donde se utilizó esto se hablará en las secciones \ref{desarrollo}, \ref{analisis} y \ref{resultado}.\vspace{\baselineskip}

Se desarrolló también una rudimentaria interfaz gráfica para tratar de evitar la utilización de la línea de comandos (en particular por la cantidad de argumentos que hay que manipular para los diversos efectos) y que la utilización del programa sea más amigable. Se hablará de ella en la sección \ref{subsec:gui}.

\newpage\subsection{Audio}
\label{subsec:audio}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{imagenes/signals.png}
    \caption{Señales de audio}
    \label{fig:signals}
\end{figure}

Simplificándolo extremamente, una señal de audio (\textbf{(b)} en la figura \ref{fig:signals}) es una representación del sonido, que puede ser visualizado como una curva continua (en el caso analógico, sus valores representan voltaje eléctrico) en función del tiempo. Al digitalizar una señal, se discretiza la curva (\textbf{(a)} en la figura \ref{fig:signals}) tomando valores cada cierta cantidad de tiempo, lo que da lugar a la \textit{frecuencia de muestreo} (\textbf{sampling rate}, expresada como cantidad de muestras por segundo, unidad \textbf{Hz}). A la vez, cada uno de esos valores no puede ser expresado con precisión infinita, sino que al pasar al dominio digital, debe poder ser representado con una cantidad específica de bits, lo que origina la \textit{tasa de bits} (\textbf{bit rate}, \textit{resolución} de una señal de audio). \vspace{\baselineskip}

El formato de audio elegido para el \textbf{TP} es WAV, por ser uno de los más simples para manipular. Los datos correspondientes al audio no están comprimidos, por lo que es posible realizar directamente sobre ellos las operaciones necesarias para aplicar los diversos efectos. \vspace{\baselineskip}

La librería utilizada para el manejo de este archivo se verá en la sección \ref{subsec:libsndfile}.\vspace{\baselineskip}

\fbox{\begin{minipage}{42em}
Por recomendación del profesor durante la presentación del proyecto de \textbf{TP}, en el archivo de audio final obtenido luego de la aplicación de alguno de los efectos, la \textit{señal seca} (\textit{dry sound/dry signal}, sin efecto) va por un canal, y la \textit{señal húmeda} (\textit{wet sound/wet signal}) por el otro. De este modo, se puede apreciar con mayor claridad el efecto en cuestión. 

\ \ \ \ Esto implica que todos los archivos de salida tendrán dos canales (\textbf{stereo}), a pesar de que el archivo de entrada pudiera haber tenido un único canal. En el caso de archivos de entrada con dos canales, se realiza un promedio de ambos (aunque esto sólo es válido en archivos stereo que mandan el mismo audio por los canales), y sobre ese nuevo ``canal'' se aplica el efecto correspondiente.
\end{minipage}}

\newpage\subsection{Herramientas externas utilizadas}
\label{subsec:herramientas}
Además de los ya mencionados \textbf{Matlab}, \textbf{RStudio}, y \textbf{Scilab}, se utilizaron las siguientas herramientas desarrolladas por terceros.

\subsubsection{libsndfile}
\label{subsec:libsndfile}
\textbf{libsndfile} es una librería de código abierto desarrollada en \textbf{C} para leer y escribir archivos de audio. Trabaja con el formato WAV, entre otros, por lo que se adaptaba a las necesidades del \textbf{TP}. La API puede consultarse aquí \footnote{\url{http://www.mega-nerd.com/libsndfile/api.html}}.\vspace{\baselineskip}

Una ventaja de la librería es que hace un pasaje de integer (tipo de datos utilizado en el formato WAV) a float, que es el tipo de datos utilizado para el \textbf{TP} \footnote{Originalmente se pensaba utilizar double, pero por recomendación del profesor se decidió pasar a float para poder procesar más datos}. Por otro lado, al leer un archivo utiliza una estructura propia llamada SF\_INFO, que incluye datos importantes del mismo (cantidad de canales, de muestras, entre otros), y que son necesarios en algunas porciones del \textbf{TP} por diversos motivos.

\subsubsection{Audacity}
\label{subsec:audacity}
\textbf{Audacity} es un editor multiplataforma de audio digital de código abierto y que en el \textbf{TP} se utilizó para realizar las comparaciones entre los archivos finales obtenidos de los diferentes efectos para cada lenguaje. De este modo, al no encontrar diferencias entre las señales de dos archivos diferentes, se podía corroborar que el algoritmo coincide con el efecto a aplicar.

\subsubsection{PyQt}
Para desarrollar la interfaz gráfica del TP, se utilizó PyQt5 (\textit{versión 5.2.1}), que provee bindings de Python (\textit{versión 3.x}) para el framework QT (\textit{versión 5.2.1}). Se verán los paquetes que será necesario instalar para usar la GUI en la sección \ref{subsec:instalar}

\subsubsection{Valgrind, KDbg, Callgrind, KCacheGrind}
Todas las herramientas mencionadas en el título fueron utilizadas para el debug del \textbf{TP}.

\subsubsection*{Valgrind}
\textbf{Valgrind} fue utilizado para saber cómo era el manejo de memoria del programa. En el caso de que el programa terminara repentinamente debido a algún \textit{segmentation fault}, mediante \textbf{Valgrind} se podía saber en qué línea del código ocurría, pasando entonces a ver cuál fue el acceso erróneo viendo los valores de los registros con \textbf{Kdbg}. 

\subsubsection*{KDbg}
Si bien en la materia se recomendaba utilizar DDD, a mi parecer tenía una interfaz bastante anticuada, y \textit{crasheaba} mucho; por esa razón se buscó una alternativa, y \textbf{Kdbg} resultó ser una opción más que adecuada para mis requerimientos, más estable y más amigable en cuanto a UI.

\subsubsection*{Callgrind}
Cuando había dudas con respecto a la performance del código en \textbf{Assembler} al compararlo con \textbf{C}, se buscó información sobre herramientas para profiling. Es posible utilizar \textbf{Valgrind} con una serie de argumentos especiales (\textit{--tool=callgrind --dump-instr=yes --collect-jumps=yes}) que devuelven un archivo de nombre callgrind.out.XXXXX (siendo XXXXX el número del proceso corrido) donde se encuentra toda la información sobre los llamados a instrucciones y dónde se pierde más tiempo en la ejecución de un programa.

\subsubsection*{KCacheGrind}
Para visualizar el archivo anterior, se utiliza KCacheGrind, que muestra toda la información de manera completamente intuitiva, y que permite identificar rápidamente dónde están los cuellos de botella del programa. Se verán los resultados obtenidos con el programa en la sección \ref{desarrolloponele}.


\newpage\subsection{Uso TP}
\subsubsection{Paquetes a instalar}
\label{subsec:instalar}
Para esta sección, se instaló la distribución Linux Mint 17.1 (basada en Ubuntu) en una máquina virtual, de modo de poder saber qué es necesario instalar en un sistema desde 0 para poder correr el \textbf{TP}.

\subsubsection*{Compilar TP}
Para poder compilar el \textbf{TP} mediante el comando \textit{Make}, se necesitan los paquetes: 
\begin{itemize}
 \item \textbf{libsndfile1-dev} (librería libsndfile)
 \item \textbf{build-essential} (librería stdio.h)
 \item \textbf{nasm}
\end{itemize}

\subsubsection*{Interfaz gráfica}
Para poder ejecutar la interfaz gráfica:
\begin{itemize}
 \item \textbf{python3}
 \item \textbf{python3-pyqt5} (bindings de Qt para python3)
 \item \textbf{python3-pyqt5.multimedia} (para poder reproducir archivos de audio desde la GUI)
\end{itemize}

\subsubsection*{Debug}
Para las herramientas de debug, es necesario instalar:
\begin{itemize}
 \item \textbf{valgrind}
 \item \textbf{kdbg}
 \item \textbf{kcachegrind}
 \item \textbf{graphviz libgraphviz-perl} (sólo para poder ver el Call Graph en KCacheGrind)
\end{itemize}

\subsubsection*{Comparación visual señales de audio}
Si se desea realizar la comparación visual de las señales de audio explicada en la sección \ref{subsec:chequeo-diferencias}, será necesario instalar el siguiente paquete:
\begin{itemize}
 \item \textbf{audacity}
\end{itemize}

\newpage\subsubsection{Linea comandos}
\label{subsec:cli}
Una vez compilado el \textbf{TP} (mediante el comando \textit{make}, pues el archivo Makefile se encuentra incluido), se puede ver la ayuda del programa ejecutando únicamente \textit{./main}. Por razones de completitud, se explica aquí también cómo utilizar el programa. \vspace{\baselineskip}

La estructura para aplicar un efecto a un archivo de audio es la siguiente:

\lstset{language=bash}
\begin{lstlisting}[frame=single]
./main INFILE OUTFILE EFFECT ARGS
\end{lstlisting}

\begin{itemize}
 \item \textbf{INFILE} es el archivo de audio de entrada, siempre en formato WAV.
 \item \textbf{OUTFILE} es el nombre deseado del archivo de salida, con extensión .WAV.
 \item \textbf{EFFECT} es un guión, seguido del caracter asociado al efecto a aplicar.
 \item \textbf{ARGS} son los argumentos dependientes del efecto definido en \textbf{EFFECT}.
\end{itemize}

La lista de los efectos y los rangos de los argumentos correspondientes (los mismos se explicarán en la sección \ref{sec:desarrollo} de Desarrollo de cada efecto) se pueden consultar en la siguiente tabla:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|l|l|c|c|l|c|l|c|c|l|l|}
\hline
\multirow{2}{*}{{\bf Nombre}} & \multicolumn{2}{c|}{{\bf Caracter}} & \multicolumn{12}{c|}{\multirow{2}{*}{{\bf Argumentos}}}                                                                                                                                                                                                                                                                                                       \\ \cline{2-3}
                              & {\bf ASM}         & {\bf C}         & \multicolumn{12}{c|}{}                                                                                                                                                                                                                                                                                                                                        \\ \hline
Copiar                        & C                 & c               & \multicolumn{12}{c|}{Ninguno}                                                                                                                                                                                                                                                                                                                                 \\ \hline
Delay                         & D                 & d               & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Delay}:\\ 0.0-5.0 segundos\end{tabular}}                                                                                & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Decay}: \\ 0.00-1.00\end{tabular}}                                                                                                      \\ \hline
Flanger                       & F                 & f               & \multicolumn{4}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Delay}: \\ 0-15 milisegundos\end{tabular}}                   & \multicolumn{4}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Rate}: \\ 0.1-5.0 hertz\end{tabular}}                                   & \multicolumn{4}{c|}{\begin{tabular}[c]{@{}c@{}}Amp: \\ 0.65-0.75\end{tabular}}                                           \\ \hline
Vibrato                       & V                 & v               & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Depth}: \\ 0-3 milisegundos\end{tabular}}                                                                               & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Mod}: \\ 0.1-5.0 hertz\end{tabular}}                                                                                                    \\ \hline
Bitcrusher                    & B                 & b               & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Bits}:\\ 1-16\end{tabular}}                                                                                             & \multicolumn{6}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Bitrate}: \\ 1-44100 hertz\end{tabular}}                                                                                                \\ \hline
Wah Wah                       & W                 & w               & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{Damp}:\\ 0.1-1.0\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{MinFreq}:\\ 400-1000 hertz\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{MaxFreq}:\\ 2500-3500 hertz\end{tabular}} & \multicolumn{3}{c|}{\begin{tabular}[c]{@{}c@{}}\underline{WahWah Freq}:\\ 1000-3000 hertz\end{tabular}} \\ \hline
\end{tabular}
\caption{Lista de comandos}
\label{tab:efectos}
\end{table}

\newpage\subsubsection{GUI}
\label{subsec:gui}
La GUI intenta ser una manera más intuitiva de ejecutar el programa, sin necesidad de tener que ingresar todos los argumentos a mano. Se ejecuta (estando en la carpeta \textbf{src}) mediante el siguiente comando:

\lstset{language=bash}
\begin{lstlisting}[frame=single]
python3 gui/main.py
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.68]{imagenes/gui.png}
    \caption{Señales de audio}
    \label{fig:gui}
\end{figure}

La GUI limpia se ve en la figura \ref{fig:gui}. Es necesario seleccionar dónde se encuentra el archivo \textbf{main}, el archivo de entrada sobre el cual se quiere aplicar el efecto, cuál es el nombre deseado del archivo de salida (se lo colocará en la misma carpeta donde se encuentra \textbf{main}) y, finalmente, el efecto a aplicar junto con sus argumentos.\vspace{\baselineskip}

La GUI con todos los argumentos completados, y luego de seleccionar el botón ``ejecutar programa'' se ve como en la figura \ref{fig:gui-complete}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.68]{imagenes/gui-complete.png}
    \caption{Señales de audio}
    \label{fig:gui-complete}
\end{figure}

En caso de que falte c

\newpage\subsubsection{Chequeo de diferencias con Audacity}
\label{subsec:chequeo-diferencias}
Para poder verificar si hay diferencias entre dos archivos de audio en Audacity, es necesario proceder del siguiente modo. Con el programa abierto, se arrastran los dos archivos hacia la ventana del mismo para que sean importados automáticamente (si es la primera vez, se va a preguntar si se quiere trabajar sobre los mismos archivos, o sobre una copia temporal de los mismos; por seguridad, se recomienda elegir esta última opción, y que el programa la recuerde).\vspace{\baselineskip}

Como ambos archivos son ``de salida'' (para nuestro programa), serán los dos stereo. Es necesario separar los canales de cada uno de los archivos, para compararlos entre sí. Hacer click sobre la flecha al lado del nombre del archivo, y clickear en ``Split Stereo to Mono'' (o presionar la tecla \textbf{n}); ver figura \ref{fig:audacity-split-stereo}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{imagenes/audacity-split-stereo.png}
    \caption{Convertir Stereo a canales Mono}
    \label{fig:audacity-split-stereo}
\end{figure}


Separados ya los canales de ambos archivos, seleccionar el canal izquierdo del primer archivo (aparecerá con un color diferente al resto), e ir al menú ``Effect'' (\textbf{Alt+c}), y elegir ``Invert''; ver figura \ref{fig:audacity-invert}.\vspace{\baselineskip}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.68]{imagenes/audacity-invert.png}
    \caption{Invertir canal}
    \label{fig:audacity-invert}
\end{figure}

Invertido, por ejemplo, el canal izquierdo del primer archivo, se selecciona dicho canal, junto con el izquierdo del segundo archivo (\textbf{shift+click} en los cuadrantes grises a la izquierda de cada señal). Con los dos canales correspondientes seleccionados, uno de ellos invertido, se va al menú ``Tracks'' (\textbf{Alt+t}), y se selecciona la opción ``Mix and Render'' (tecla \textbf{x}); ver figura \ref{fig:audacity-mix-and-render}.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{imagenes/audacity-mix-and-render.png}
    \caption{Mix and render}
    \label{fig:audacity-mix-and-render}
\end{figure}

Los dos canales seleccionados que fueron mezclados, originalmente tenían la misma información. Al invertir uno de ellos, y mezclarlos entre sí, se produce una cancelación de la onda. Por lo tanto, si efectivamente contenían la misma información, debería verse el nuevo canal generado completamente vacío; ver figura \ref{fig:audacity-no-wave}. Durante el desarrollo del \textbf{TP}, esto a veces se consiguió y otras no, y las razones de ello se verán en las secciones correspondientes.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.70]{imagenes/audacity-no-wave.png}
    \caption{Cancelación de la onda}
    \label{fig:audacity-no-wave}
\end{figure}

El canal izquierdo es la señal seca; repetir luego el mismo procedimiento con los dos canales derechos restantes.


\newpage\section{Fuentes}
\begin{itemize}
\item Figura \ref{fig:signals}: \url{http://msp.ucsd.edu/techniques/v0.11/book-html/node7.html}
\end{itemize}

\newpage\section{Bibliografía tentativa}
\subsection{Libros}
\begin{thebibliography}{9}
 \bibitem{boulanger11}
  Richard Boulanger, Victor Lazzarini
  \emph{The Audio Programming Book},
  2011, The MIT Press, Massachussets (USA)
 
 \bibitem{moore90}
  F. Richard Moore,
  \emph{Elements of Computer Music},
  1990, Prentice Hall, New Jersey (USA)

  \bibitem{orfanidis10}
  Sophocles J. Orfanidis,
  \emph{Introduction to Signal Processing}, \\
  \url{http://www.ece.rutgers.edu/~orfanidi/intro2sp/}
  
  \bibitem{roads96}
  Curtis Roads,
  \emph{The Computer Music Tutorial},
  1996, The MIT Press, Massachussets (USA)
  \bibitem{rocchesso03}
  Davide Rocchesso,
  \emph{Introduction to Sound Processing},
  \url{profs.sci.univr.it/~rocchess/SP/sp.pdf}
  
  \bibitem{smith99}
  Steven W. Smith,
  \emph{The Scientist and Engineer's Guide to Digital Signal Processing},
  Second Edition, 1999, California Technical Publishing, California (USA)
  
  \bibitem{zolzer11}
  Udo Zölzer,
  \emph{DAFX: Digital Audio Effects}
  Second Edition, 2011, Wiley and Sons, Hamburg (Germany)
\end{thebibliography}
  
\subsection{Internet}

\begin{itemize}
\item \url{http://www.mega-nerd.com/libsndfile/api.html}
\item \url{http://stackoverflow.com}
\item \url{https://ccrma.stanford.edu/~jos/}
\item \url{http://www.musicdsp.org/}
\item \url{http://www.kvraudio.org/}
\end{itemize}

\end{document}
